name: Self-Healing CI

on:
  workflow_run:
    workflows: ["CI"]
    branches: [main]
    types: [completed]

permissions:
  issues: write
  actions: read
  checks: read

jobs:
  create-fix-issue:
    name: Create CI Fix Issue
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'failure'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure labels exist
        uses: actions/github-script@v7
        with:
          script: |
            const labels = [
              { name: 'ci-fix', color: 'd73a4a', description: 'Automated CI failure fix request' },
              { name: 'automated', color: '0e8a16', description: 'Created by automation' }
            ];
            for (const label of labels) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ...label
                  });
                }
              }
            }

      - name: Fetch workflow run details
        id: workflow-details
        uses: actions/github-script@v7
        with:
          script: |
            const runId = context.payload.workflow_run.id;
            const sha = context.payload.workflow_run.head_sha;
            const shortSha = sha.substring(0, 7);
            const jobs = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });
            const failedJobs = jobs.data.jobs.filter(job => job.conclusion === 'failure');
            if (failedJobs.length === 0) return { failedJobs: [], sha, shortSha };
            const jobLogs = [];
            for (const job of failedJobs) {
              try {
                const logs = await github.rest.actions.downloadJobLogsForWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  job_id: job.id
                });
                const logLines = logs.data.split('\n');
                jobLogs.push({ name: job.name, log: logLines.slice(-200).join('\n') });
              } catch (error) {
                jobLogs.push({ name: job.name, log: 'Failed to fetch logs' });
              }
            }
            return { failedJobs: failedJobs.map(j => j.name), jobLogs, sha, shortSha, runUrl: context.payload.workflow_run.html_url };

      - name: Check for existing open issue
        id: check-issue
        uses: actions/github-script@v7
        with:
          script: |
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'ci-fix,automated'
            });
            if (issues.data.length > 0) {
              const issue = issues.data[0];
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number
              });
              const workflowComments = comments.data.filter(c => c.body.includes('## New Failure Detected'));
              return { exists: true, number: issue.number, commentCount: workflowComments.length };
            }
            return { exists: false, number: null, commentCount: 0 };

      - name: Create or update issue
        id: create-issue
        uses: actions/github-script@v7
        with:
          script: |
            const workflowDetails = ${{ steps.workflow-details.outputs.result }};
            const issueCheck = ${{ steps.check-issue.outputs.result }};
            if (workflowDetails.failedJobs.length === 0) return { issueNumber: null };
            let logsSection = '';
            for (const jobLog of workflowDetails.jobLogs) {
              logsSection += `### Job: ${jobLog.name}\n\n\`\`\`\n${jobLog.log}\n\`\`\`\n\n`;
            }
            if (!issueCheck.exists) {
              const issueBody = `## CI Failure â€” Auto-generated

            The CI workflow failed on branch \`main\` at commit \`${workflowDetails.sha}\`.

            **Failed run:** ${workflowDetails.runUrl}

            ## Task

            Analyze the failure logs below and fix the code that is causing CI to fail.

            **Rules:**
            - Fix the root cause in the source code, tests, or configuration
            - Do NOT skip, disable, or mark any tests as expected failures
            - Do NOT add \`continue-on-error\` or any other workaround
            - Run the full test suite locally before submitting your PR
            - Keep your changes minimal and focused on the fix

            ## Failure Logs

            ${logsSection}`;

              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[CI Fix] CI failure on \`main\` (${workflowDetails.shortSha})`,
                body: issueBody,
                labels: ['ci-fix', 'automated']
              });
              console.log(`Created issue #${issue.data.number}`);
              return { issueNumber: issue.data.number };
            } else if (issueCheck.commentCount < 3) {
              const commentBody = `## New Failure Detected

            **Failed run:** ${workflowDetails.runUrl}
            **Commit:** \`${workflowDetails.sha}\`

            ## Failure Logs

            ${logsSection}`;

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueCheck.number,
                body: commentBody
              });
              return { issueNumber: issueCheck.number };
            } else {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueCheck.number,
                labels: ['needs-human']
              });
              return { issueNumber: issueCheck.number };
            }

      - name: Assign to Copilot
        if: steps.create-issue.outputs.result != 'null' && steps.check-issue.outputs.result == '{"exists":false,"number":null,"commentCount":0}'
        env:
          GH_TOKEN: ${{ secrets.MITCHELL_PAT }}
        run: |
          ISSUE_NUMBER=$(echo '${{ steps.create-issue.outputs.result }}' | jq -r '.issueNumber')
          if [ "$ISSUE_NUMBER" != "null" ] && [ -n "$ISSUE_NUMBER" ]; then
            echo "Assigning issue #$ISSUE_NUMBER to Copilot..."
            gh api \
              --method POST \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              /repos/${{ github.repository }}/issues/${ISSUE_NUMBER}/assignees \
              -f 'assignees[]=copilot-swe-agent[bot]' || echo "Failed to assign to Copilot"
          fi
