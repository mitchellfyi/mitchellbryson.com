name: "AI Automation: Conflict Resolution"

# Detects merge conflicts on AI-managed PRs and asks Claude to fix them
# Runs when main changes (after CI) to catch conflicts early

on:
  workflow_run:
    workflows:
      - CI
    types:
      - completed
    branches:
      - main

  # Also can be triggered manually
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write

jobs:
  check-conflicts:
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Find PRs with conflicts
        id: find
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          REPO="${{ github.repository }}"
          
          echo "::group::Checking for conflicting PRs"
          
          # Get all open PRs on AI-managed branches
          PRS=$(gh pr list --repo "$REPO" --state open --json number,headRefName,labels \
            --jq '.[] | select(
              (.headRefName | (startswith("copilot/") or startswith("ai/"))) or
              (.labels[].name | (. == "ai-fix" or . == "ai-maintenance"))
            ) | .number' || echo "")
          
          if [ -z "$PRS" ]; then
            echo "No AI-managed PRs to check"
            echo "conflicting_prs=" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
          fi
          
          echo "Found PRs: $PRS"
          
          CONFLICTING=""
          for PR_NUM in $PRS; do
            echo "Checking PR #$PR_NUM..."
            
            # Give GitHub time to compute mergeable status
            sleep 3
            
            PR_DATA=$(gh api repos/$REPO/pulls/$PR_NUM --jq '{mergeable: .mergeable, state: .mergeable_state, branch: .head.ref}' 2>/dev/null || echo "{}")
            MERGEABLE=$(echo "$PR_DATA" | jq -r '.mergeable // "unknown"')
            MERGEABLE_STATE=$(echo "$PR_DATA" | jq -r '.state // "unknown"')
            BRANCH=$(echo "$PR_DATA" | jq -r '.branch // "unknown"')
            
            echo "  mergeable: $MERGEABLE, state: $MERGEABLE_STATE, branch: $BRANCH"
            
            if [ "$MERGEABLE" = "false" ] || [ "$MERGEABLE_STATE" = "dirty" ]; then
              echo "  ⚠️ PR #$PR_NUM has conflicts!"
              CONFLICTING="$CONFLICTING $PR_NUM"
            fi
          done
          
          echo "conflicting_prs=$CONFLICTING" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Ask Claude to fix conflicts
        if: steps.find.outputs.conflicting_prs != ''
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          REPO="${{ github.repository }}"
          
          for PR_NUM in ${{ steps.find.outputs.conflicting_prs }}; do
            echo "::group::Asking Claude to fix PR #$PR_NUM"
            
            # Check if we already asked recently (avoid spam)
            RECENT_ASK=$(gh api repos/$REPO/issues/$PR_NUM/comments \
              --jq '[.[] | select(.body | contains("Merge Conflict Detected") and contains("@claude"))] | sort_by(.created_at) | last | .created_at // ""' 2>/dev/null || echo "")
            
            if [ -n "$RECENT_ASK" ]; then
              ASK_TIME=$(date -d "$RECENT_ASK" +%s 2>/dev/null || echo "0")
              NOW=$(date +%s)
              AGE=$((NOW - ASK_TIME))
              
              if [ "$AGE" -lt 3600 ]; then
                echo "Already asked Claude within the last hour - skipping"
                echo "::endgroup::"
                continue
              fi
            fi
            
            gh pr comment $PR_NUM --repo $REPO --body "⚠️ **Merge Conflict Detected**

This PR has a merge conflict with \`main\`.

@claude Please resolve by merging main and fixing conflicts:

\`\`\`bash
git fetch origin main
git merge origin/main
\`\`\`

Edit conflicting files to resolve them (look for \`<<<<<<<\`, \`=======\`, \`>>>>>>>\` markers), then:

\`\`\`bash
git add .
git commit -m 'fix: Merge main and resolve conflicts'
git push
\`\`\`"
            
            echo "✓ Asked Claude to fix PR #$PR_NUM"
            echo "::endgroup::"
          done
